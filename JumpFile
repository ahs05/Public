<#
.SYNOPSIS
    List all Applications in ConfigMgr 2012 that have one or more dependencies configured
.DESCRIPTION
    This script will enumerate through all the Applications in ConfigMgr 2012 and output a custom object for those applications
    that have a dependency configured for any of the DeploymentTypes
.PARAMETER SiteServer
    Site server name with SMS Provider installed
.PARAMETER ShowProgress
    Show a progressbar displaying the current operation
.EXAMPLE
    List Applications with dependencies on a Primary Site server called 'CM01':
    .\Get-CMApplicationWithDependency.ps1 -SiteServer -ShowProgress
.NOTES
    Script name: Get-CMApplicationWithDependency.ps1
    
#>
[CmdletBinding(SupportsShouldProcess=$true)]
param(
    [parameter(Mandatory=$true, HelpMessage="Site server where the SMS Provider is installed")]
    [ValidateNotNullOrEmpty()]
    [ValidateScript({Test-Connection -ComputerName $_ -Count 1 -Quiet})]
    [string]$SiteServer,
    [parameter(Mandatory=$false, HelpMessage="Show a progressbar displaying the current operation")]
    [switch]$ShowProgress
)
Begin {
    # Determine SiteCode from WMI
    try {
        Write-Verbose -Message "Determining SiteCode for Site Server: '$($SiteServer)'"
        $SiteCodeObjects = Get-WmiObject -Namespace "root\SMS" -Class SMS_ProviderLocation -ComputerName $SiteServer -ErrorAction Stop
        foreach ($SiteCodeObject in $SiteCodeObjects) {
            if ($SiteCodeObject.ProviderForLocalSite -eq $true) {
                $SiteCode = $SiteCodeObject.SiteCode
                Write-Debug -Message "SiteCode: $($SiteCode)"
            }
        }
    }
    catch [System.UnauthorizedAccessException] {
        Write-Warning -Message "Access denied" ; break
    }
    catch [System.Exception] {
        Write-Warning -Message "Unable to determine SiteCode" ; break
    }
    # Load ConfigMgr application assemblies
    try {
        Add-Type -Path (Join-Path -Path (Get-Item $env:SMS_ADMIN_UI_PATH).Parent.FullName -ChildPath "Microsoft.ConfigurationManagement.ApplicationManagement.dll") -ErrorAction Stop
        Add-Type -Path (Join-Path -Path (Get-Item $env:SMS_ADMIN_UI_PATH).Parent.FullName -ChildPath "Microsoft.ConfigurationManagement.ApplicationManagement.Extender.dll") -ErrorAction Stop
        Add-Type -Path (Join-Path -Path (Get-Item $env:SMS_ADMIN_UI_PATH).Parent.FullName -ChildPath "Microsoft.ConfigurationManagement.ApplicationManagement.MsiInstaller.dll") -ErrorAction Stop
    }
    catch [System.UnauthorizedAccessException] {
	    Write-Warning -Message "Access was denied when attempting to load ApplicationManagement dll's" ; break
    }
    catch [System.Exception] {
	    Write-Warning -Message "Unable to load required ApplicationManagement dll's. Make sure that you're running this tool on system where the ConfigMgr console is installed and that you're running the tool elevated" ; break
    }
}
Process {
    if ($PSBoundParameters["ShowProgress"]) {
        $ProgressCount = 0
    }
    try {
        $Applications = Get-WmiObject -Namespace "root\SMS\site_$($SiteCode)" -Class "SMS_ApplicationLatest" -ComputerName $SiteServer -ErrorAction Stop
        $ApplicationCount = ($Applications | Measure-Object).Count
        foreach ($Application in $Applications) {
            if ($PSBoundParameters["ShowProgress"]) {
                $ProgressCount++
                Write-Progress -Activity "Enumerating Applications for dependencies" -Status "Application $($ProgressCount) / $($ApplicationCount)" -Id 1 -PercentComplete (($ProgressCount / $ApplicationCount) * 100)
            }
            $ApplicationName = $Application.LocalizedDisplayName
            # Get Application object including Lazy properties
            $Application.Get()
            # Deserialize SDMPakageXML property from string
            $ApplicationXML = [Microsoft.ConfigurationManagement.ApplicationManagement.Serialization.SccmSerializer]::DeserializeFromString($Application.SDMPackageXML, $true)
            foreach ($DeploymentType in $ApplicationXML.DeploymentTypes) {
                if ([int]$DeploymentType.Dependencies.Count -ge 1) {
                    $PSObject = [PSCustomObject]@{
                        ApplicationName = $ApplicationName
                        DeploymentTypeName = $DeploymentType.Title
                        DependencyCount = $DeploymentType.Dependencies.Count
                        DependencyGroupName = $DeploymentType.Dependencies.Name
                        DependentApplication = $DeploymentType.Dependencies.Expression.Operands | ForEach-Object {
                            Get-WmiObject -Namespace "root\SMS\site_$($SiteCode)" -Class "SMS_ApplicationLatest" -ComputerName $SiteServer -Filter "CI_UniqueID like '$($_.ApplicationAuthoringScopeId)%$($_.ApplicationLogicalName)%'" | Select-Object -ExpandProperty LocalizedDisplayName
                        }
                        EnforceDesiredState = $DeploymentType.Dependencies.Expression.Operands.EnforceDesiredState
                    }
                    Write-Output -InputObject $PSObject
                }
            }
        }
    }
    catch [System.Exception] {
        Write-Warning -Message $_.Exception.Message ; break
    }
}
End {
    if ($PSBoundParameters["ShowProgress"]) {
        Write-Progress -Activity "Enumerating Applications for dependencies" -Id 1 -Completed
    }
}
--------


<#
.SYNOPSIS
    Checks if BitLocker keys for Windows devices are stored in Entra ID based on a list of devices from a CSV file.

.DESCRIPTION
    This script reads a list of devices from a specified CSV file, connects to the Microsoft Graph API, and checks if each device
    has a BitLocker key stored in Entra ID. The results are displayed in a table and exported to a CSV file.

.EXAMPLE
    .\BitLocker_EntraID_Check.ps1 -CsvPath "DeviceList.csv"

.NOTES
    Author: Ugur Koc (Modified by [Your Name])
    GitHub: https://github.com/ugurkocde
    Twitter: https://x.com/UgurKocDe
    LinkedIn: https://www.linkedin.com/in/ugurkocde/

    Version: 1.2
    Created: 31/07/2024
    Updated: [Today's Date]
    Changes: Read device list from CSV file.

    Required Permissions:
    - DeviceManagementManagedDevices.Read.All
    - BitlockerKey.Read.All

    Disclaimer: This script is provided AS IS without warranty of any kind.
#>

param (
    [string]$CsvPath = "DeviceList.csv"
)

# Check if the CSV file exists
if (-not (Test-Path -Path $CsvPath)) {
    Write-Host "CSV file not found at path: $CsvPath. Please provide a valid CSV file path." -ForegroundColor Red
    exit 1
}

# Check if Microsoft.Graph.Authentication module is installed and import it
if (-not (Get-Module -ListAvailable -Name Microsoft.Graph.Authentication)) {
    Write-Host "Microsoft.Graph.Authentication module not found. Attempting to install..." -ForegroundColor Yellow
    try {
        Install-Module -Name Microsoft.Graph.Authentication -Scope CurrentUser -Force -AllowClobber
        Write-Host "Microsoft.Graph.Authentication module installed successfully" -ForegroundColor Green
    }
    catch {
        Write-Host "Failed to install Microsoft.Graph.Authentication module: $_" -ForegroundColor Red
        Write-Host "Please install the Microsoft.Graph.Authentication module manually and rerun the script" -ForegroundColor Red
        exit 1
    }
}

# Connect to Microsoft Graph
Connect-MgGraph -Scopes "DeviceManagementManagedDevices.Read.All", "BitlockerKey.Read.All" -NoWelcome

# Function to get BitLocker key for a device
function Get-BitLockerKey {
    param (
        [string]$azureADDeviceId
    )

    $keyIdUri = "https://graph.microsoft.com/beta/informationProtection/bitlocker/recoveryKeys?`$filter=deviceId eq '$azureADDeviceId'"
    $keyIdResponse = Invoke-MgGraphRequest -Uri $keyIdUri -Method GET

    if ($keyIdResponse.value.Count -gt 0) {
        return "Yes"
    }
    return "No"
}

# Import the list of devices from the CSV file
$deviceList = Import-Csv -Path $CsvPath

# Check if the CSV file has the necessary column (assuming 'AzureADDeviceId')
if (-not $deviceList | Get-Member -Name 'AzureADDeviceId') {
    Write-Host "CSV file does not have a column named 'AzureADDeviceId'. Please ensure the CSV file has the correct format." -ForegroundColor Red
    exit 1
}

$results = @()

foreach ($device in $deviceList) {
    $azureADDeviceId = $device.AzureADDeviceId

    if ([string]::IsNullOrWhiteSpace($azureADDeviceId)) {
        Write-Host "Device entry with missing AzureADDeviceId found. Skipping this entry..." -ForegroundColor Yellow
        continue
    }

    $hasBitlockerKey = Get-BitLockerKey -azureADDeviceId $azureADDeviceId

    $results += [PSCustomObject]@{
        "AzureAD Device ID" = $azureADDeviceId
        DeviceName = $device.DeviceName
        SerialNumber = $device.SerialNumber
        "BitLocker Key in EntraID" = $hasBitlockerKey
    }
}

# Display results
$results | Format-Table -AutoSize

# Calculate summary statistics
$totalDevices = $results.Count
$devicesWithKey = ($results | Where-Object { $_.'BitLocker Key in EntraID' -eq 'Yes' }).Count
$devicesWithoutKey = $totalDevices - $devicesWithKey

# Display summary
Write-Host "`nSummary:" -ForegroundColor Cyan
Write-Host "Total devices checked: $totalDevices" -ForegroundColor Yellow
Write-Host "Devices with BitLocker key stored in Entra ID: $devicesWithKey" -ForegroundColor Green
Write-Host "Devices without BitLocker key stored in Entra ID: $devicesWithoutKey" -ForegroundColor Red

# Export results to CSV
$results | Export-Csv -Path "BitLockerKeyStatus.csv" -NoTypeInformation
