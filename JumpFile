 https://www.kb.ischool.uw.edu/2022/02/04/set-up-ischool-issued-windows-computer/

https://www.bleepingcomputer.com/news/microsoft/microsoft-fixes-print-to-pdf-feature-broken-by-windows-update/

https://www.catalog.update.microsoft.com/Search.aspx?q=KB5060829

S
---------------------------------------------------
Start of Script
---------------------------------------
Refer all these Articles for Clean up Hard Drive (C:\): 

https://prosystech.nl/powershell-clean-up-hard-drive-c/
https://level.io/library/script-windows-disk-cleanup
https://roheed.com/free-up-disk-space-using-powershell/
https://darwinsdata.com/how-do-i-run-a-disk-cleanup-in-powershell/
https://www.geeksforgeeks.org/linux-unix/disk-cleanup-using-powershell-scripts/(Less intrusive Way)

Defender Error Fix: https://www.windows11forums.com/threads/windows-11-defender-firewall-will-not-load.355/#post-3757
Defender Error Fix: https://techlou.com/fix-unable-to-delete-all-specified-values-error-in-registry-editor/
https://windowsforum.com/threads/win11-upgrade-2025-07-cu-causing-mpssvc-break.375192/
---------------------------------------------------

# Define the registry key path
$RegPath = "HKLM:\SOFTWARE\7-Zip\Hari"

# Get the current ACL of the registry key
$acl = Get-Acl -Path $RegPath

# Create a new access rule
# BUILTIN\Users = all local users
# BUILTIN\Administrators = Local admins group
# NT AUTHORITY\Authenticated Users = All authenticated users (domain or local)
# FullControl = full rights
# ContainerInherit, ObjectInherit = apply to subkeys
# None = no special propagation flags
# Allow = grant permissions
$rule = New-Object System.Security.AccessControl.RegistryAccessRule(
    "BUILTIN\Users",
    "FullControl",
    "ContainerInherit,ObjectInherit",
    "None",
    "Allow"
)

# Add the rule to the ACL
$acl.SetAccessRule($rule)

# Apply the ACL back to the registry key
Set-Acl -Path $RegPath -AclObject $acl


---------

# Define the registry key path
$RegPath = "HKLM:\SYSTEM\CurrentControlSet\Services\mpssvc\Parameters\AppCs"

# Step 1: Take ownership
$owner = [System.Security.Principal.NTAccount]"BUILTIN\Administrators"
$acl = Get-Acl -Path $RegPath
$acl.SetOwner($owner)
Set-Acl -Path $RegPath -AclObject $acl

# Step 2: Add full control for Authenticated Users
$acl = Get-Acl -Path $RegPath
$rule = New-Object System.Security.AccessControl.RegistryAccessRule(
    "NT AUTHORITY\Authenticated Users",
    "FullControl",
    "ContainerInherit,ObjectInherit",
    "None",
    "Allow"
)
$acl.SetAccessRule($rule)
Set-Acl -Path $RegPath -AclObject $acl

# Step 3 (Optional): Restore ownership to the service account
# (This keeps Windows happy and avoids service issues)
$svcOwner = New-Object System.Security.Principal.NTAccount("NT SERVICE\MpsSvc")
$acl = Get-Acl -Path $RegPath
$acl.SetOwner($svcOwner)
Set-Acl -Path $RegPath -AclObject $acl


---------------------------


# Define the registry key path
$RegPath = "HKLM:\SYSTEM\CurrentControlSet\Services\mpssvc\Parameters\AppCs"

# --- Step 0: Force .NET RegistryKey object (sometimes Get-Acl fails directly) ---
$regKey = [Microsoft.Win32.Registry]::LocalMachine.OpenSubKey(
    "SYSTEM\CurrentControlSet\Services\mpssvc\Parameters\AppCs",
    [Microsoft.Win32.RegistryKeyPermissionCheck]::ReadWriteSubTree,
    [System.Security.AccessControl.RegistryRights]::TakeOwnership
)

if (-not $regKey) {
    Write-Error "Failed to open registry key: $RegPath"
    exit
}

# --- Step 1: Take ownership ---
$acl = $regKey.GetAccessControl([System.Security.AccessControl.AccessControlSections]::All)
$owner = [System.Security.Principal.NTAccount]"BUILTIN\Administrators"
$acl.SetOwner($owner)
$regKey.SetAccessControl($acl)

# --- Step 2: Add full control for Authenticated Users ---
$acl = $regKey.GetAccessControl()
$rule = New-Object System.Security.AccessControl.RegistryAccessRule(
    "NT AUTHORITY\Authenticated Users",
    [System.Security.AccessControl.RegistryRights]::FullControl,
    [System.Security.AccessControl.InheritanceFlags]::ContainerInherit -bor [System.Security.AccessControl.InheritanceFlags]::ObjectInherit,
    [System.Security.AccessControl.PropagationFlags]::None,
    [System.Security.AccessControl.AccessControlType]::Allow
)
$acl.SetAccessRule($rule)
$regKey.SetAccessControl($acl)

# --- Step 3 (Optional): Restore ownership back to MpsSvc ---
$acl = $regKey.GetAccessControl()
$svcOwner = New-Object System.Security.Principal.NTAccount("NT SERVICE\MpsSvc")
$acl.SetOwner($svcOwner)
$regKey.SetAccessControl($acl)

$regKey.Close()

----------------------------
#4
$tok = [System.Security.Principal.WindowsIdentity]::GetCurrent().Token
$SE_TAKE_OWNERSHIP = 0x14
$null = [advapi32]::AdjustTokenPrivileges($tok, $false, [PSCustomObject]@{PrivilegeCount=1; Luid=$SE_TAKE_OWNERSHIP; Attributes=2}, 0, [IntPtr]::Zero, [IntPtr]::Zero)
Write-Host "SeTakeOwnershipPrivilege enabled for this session."

------------------------
#5
# Step 1: Define the registry key path
$RegPath = "HKLM:\SYSTEM\CurrentControlSet\Services\mpssvc\Parameters\AppCs"

# Step 2: Open the registry key with ReadWrite permissions
$RegKey = [Microsoft.Win32.Registry]::LocalMachine.OpenSubKey(
    "SYSTEM\CurrentControlSet\Services\mpssvc\Parameters\AppCs", 
    [Microsoft.Win32.RegistryKeyPermissionCheck]::ReadWriteSubTree, 
    [System.Security.AccessControl.RegistryRights]::ChangePermissions
)

# Step 3: Get the current ACL
$acl = $RegKey.GetAccessControl()

# Step 4: Set the owner to Administrators (or your current user)
$owner = [System.Security.Principal.NTAccount]"Administrators"
$acl.SetOwner($owner)

# Step 5: Apply the new ACL
$RegKey.SetAccessControl($acl)

# Step 6: Grant FullControl to Administrators
$rule = New-Object System.Security.AccessControl.RegistryAccessRule (
    "Administrators", "FullControl", "ContainerInherit,ObjectInherit", "None", "Allow"
)
$acl.AddAccessRule($rule)
$RegKey.SetAccessControl($acl)

$RegKey.Close()

Write-Host "Ownership and full control granted. You can now modify the key."

--------------

#Export 
$HiveRoot = "HKLM\SYSTEM\CurrentControlSet\Services\mpssvc\Parameters\AppCs"
$OutFile = "C:\Temp\Appcs.hiv"
Start-Process -FilePath reg -ArgumentList "save `"$HiveRoot`" `"$OutFile`"" -Wait -NoNewWindow
Write-Host "Saved $HiveRoot to $OutFile"

-----------
#Import

# Path to your hive file
$HiveFile = "C:\Users\hkaka\Downloads\firewall_fix_windows_11\mpssvc.hiv"

# Mount location under HKEY_LOCAL_MACHINE (can also use HKEY_USERS)
$MountPoint = "TempHive"

# Load the hive
reg load "HKLM\$MountPoint" $HiveFile
Write-Host "Hive loaded at HKLM:\$MountPoint"
---------------
https://www.systemcenterdudes.com/deploy-windows-10-extended-security-update-key-with-intune-or-sccm/

Process Overview: Role-Based Grouping and Automation

1. Define Job Personas

    Clearly outline key Job Personas across the organization (e.g., Finance Analyst, Field Engineer, Support Staff).
    Each persona should represent a distinct set of access, application, and configuration needs.

2. Add Persona Attribute in Active Directory

    Introduce a dedicated AD attribute (e.g., JobPersona or RoleProfile) per user account.
    Populate this attribute for each user based on their identified persona.

3. Automate Group Creation

    Use the AD attribute to dynamically create and maintain security groups aligned to each persona.
    This ensures consistent membership and simplifies role-based targeting.

4. Replicate Across Management Systems

    SCCM / MECM – Sync groups for software deployments and compliance baselines.
    Intune / MEM – Leverage persona-based groups for application, policy, and configuration profile targeting.
    Active Directory / Entra ID – Ensure unified identity and access alignment across on-prem and cloud environments.

5. Enable Central Governance

    Establish automated workflows or scripts to keep group membership up to date.
    Monitor changes and maintain audit trails for compliance and reporting.

6. Business Impact

    Streamlined onboarding and access provisioning.
    Consistent experience across devices and platforms.
    Reduced administrative overhead and misconfiguration risk.
    Enhanced security and governance through persona-driven policy enforcement.

-----------------------------------

<#
.SYNOPSIS
    Deletes the DWORD value 'AllowCMD' from:
    HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\DataCollection
    across all user profiles on the system.

.NOTES
    Safe for SCCM/Intune deployment.
#>

# =======================
#  Logging + Transcript
# =======================
$LogPath = "C:\Windows\Temp\Delete-AllowCMD.log"
Start-Transcript -Path $LogPath -Append

Write-Output "=== Starting AllowCMD removal script ==="

# Registry value & path
$SubKeyPath = "SOFTWARE\Policies\Microsoft\Windows\DataCollection"
$ValueName = "AllowCMD"

# Get all profile directories except system profiles
$UserProfiles = Get-ChildItem "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList" |
    Where-Object { 
        $_.GetValue("ProfileImagePath") -notmatch "systemprofile|LocalService|NetworkService"
    }

foreach ($Profile in $UserProfiles) {
    try {
        $SID = $Profile.PSChildName
        $ProfilePath = $Profile.GetValue("ProfileImagePath")

        Write-Output "Processing profile: $ProfilePath ($SID)"

        # Check if hive already loaded under HKU
        if (-not (Test-Path "HKU:\$SID")) {
            Write-Output "Loading user hive for $SID"
            reg load "HKU\$SID" "$ProfilePath\NTUSER.DAT" | Out-Null
            $HiveLoaded = $true
        } else {
            $HiveLoaded = $false
        }

        $FullKeyPath = "HKU:\$SID\$SubKeyPath"

        # Delete the value if present
        if (Test-Path $FullKeyPath) {
            if (Get-ItemProperty -Path $FullKeyPath -Name $ValueName -ErrorAction SilentlyContinue) {
                Write-Output "Deleting value '$ValueName' for $SID"
                Remove-ItemProperty -Path $FullKeyPath -Name $ValueName -ErrorAction SilentlyContinue
            } else {
                Write-Output "Value '$ValueName' not found for $SID"
            }
        } else {
            Write-Output "Key path not found for $SID"
        }

        # Unload hive if we loaded it
        if ($HiveLoaded) {
            Write-Output "Unloading hive for $SID"
            reg unload "HKU\$SID" | Out-Null
        }

    }
    catch {
        Write-Output "Error processing $SID: $_"
    }
}

Write-Output "=== Script completed ==="

Stop-Transcript

