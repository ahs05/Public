**Subject:** Request for Guidance on Access Provisioning for New Team Member  

Dear [Admin Team / Specific Contact Name],  

I hope this email finds you well.  

A new member has recently joined our team to assist with the ongoing **Oracle to Azul Migration** efforts. I would appreciate your guidance on how to grant him the necessary access to the following systems:  

1. **SCCM Console**  
   - Required to monitor and manage deployments as part of the migration.  

2. **SCCM Database**  
   - Access to run queries for reporting and troubleshooting purposes.  

3. **Active Directory Users and Computers (ADUC) Console**  
   - Needed for managing user accounts and performing directory-related tasks associated with the migration.  

Please let me know the process and prerequisites for provisioning these accesses, as well as any forms or approvals required. If additional information about the new team member is needed, I can provide that promptly.  

Thank you for your assistance! Please let me know if you have any questions or need further clarification.  

Best regards,  



#Uninstall Java
$uninstallapplist = @(Get-ChildItem HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall | 
    foreach-object {get-itemproperty $_.PSPath} |
    select-object DisplayName,InstallLocation,uninstallstring |
    Where-Object {$_.DisplayName -ne $null -and $_.uninstallstring -ne $null -and $_.InstallLocation -ne $null})

$uninstallapplist += @(Get-ChildItem HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall | 
    foreach-object {get-itemproperty $_.PSPath} |
    select-object DisplayName,InstallLocation,uninstallstring |
    Where-Object {$_.DisplayName -ne $null -and $_.uninstallstring -ne $null -and $_.InstallLocation -ne $null})

if (test-path HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall) {
	$uninstallapplist += @(Get-ChildItem HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall | 
	    ForEach-Object {get-itemproperty $_.PSPath} |
	    select-object DisplayName,InstallLocation,uninstallstring |
	    Where-Object {$_.DisplayName -ne $null -and $_.uninstallstring -ne $null -and $_.InstallLocation -ne $null})
}

# You can add additional uninstalls by copying and pasting the {$_.DisplayName -like "*Ask*" -or {$_.DisplayName -like "*Ask*" -or...
$uninstallapplist = $uninstallapplist | Where-Object {$_.InstallLocation -like "*jre*" } |
                                             sort-object DisplayName -Unique


# Now that we have the list - let's go through each one and uninstall it

foreach ($app in $uninstallapplist) {
	write-host "Uninstalling $($app.displayname) ...."
	if ($app.uninstallstring -like "msiexec.exe*") { 
    	$app.uninstallstring = $app.uninstallstring -replace "/I","/X"  
    	$app.uninstallstring = $app.uninstallstring -replace "msiexec.exe ","" 
    	$app.uninstallstring = "$($app.uninstallstring) /qn"
		
		$retcode = (start-process -filepath "msiexec.exe" -ArgumentList "$($app.uninstallstring)" -wait -passthru).exitcode
		
	}
	# If the uninstall command is not an msiexec program then we do things differently - Note: I have included the following code but not tested it yet - It should work :-)
	else {
		# If the uninstall command itself has double quotes around it because it has spaces in the path, then we have to use the "&" prefix
		if ($app.UninstallString[0] -eq '"') {Invoke-Expression "& $('$app.uninstallstring')"}
		# Otherwise we just invoke the uninstall string 
		else {Invoke-Expression "& $('$app.uninstallstring') /S"}
		# and get the exit code
		$retcode = $LASTEXITCODE
	}
	write-host "$($app.displayname) uninstalled - Return code: $retcode"
}
