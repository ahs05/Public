Download the media for the New JDK Discovery Tool from Azul's FTP site.
Package the tool and set the Command Line as:
amt-liveproc-scan.exe -WmiClass=AZUL_JavaLiveInventory.
Update the SCCM Client settings policy (Hardware Inventory Classes) to include the new WMI Class (AZUL_JavaLiveInventory) for inventory.
Create a Device Collection in SCCM and populate it with the list of your target machines. Deploy the packaged application to the target device collections as a required deployment, with rerun behavior set to run every 2 hours for 2â€“3 days (based on your requirements).
The results will now be saved on the local WMI repository and can be exported using SCCM.
Collect a full report from the SCCM database and export the data to Excel. For verification, you can use the following SQL query:


Send the data to Azul for further analysis.


#Uninstall Java
$uninstallapplist = @(Get-ChildItem HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall | 
    foreach-object {get-itemproperty $_.PSPath} |
    select-object DisplayName,InstallLocation,uninstallstring |
    Where-Object {$_.DisplayName -ne $null -and $_.uninstallstring -ne $null -and $_.InstallLocation -ne $null})

$uninstallapplist += @(Get-ChildItem HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall | 
    foreach-object {get-itemproperty $_.PSPath} |
    select-object DisplayName,InstallLocation,uninstallstring |
    Where-Object {$_.DisplayName -ne $null -and $_.uninstallstring -ne $null -and $_.InstallLocation -ne $null})

if (test-path HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall) {
	$uninstallapplist += @(Get-ChildItem HKCU:\Software\Microsoft\Windows\CurrentVersion\Uninstall | 
	    ForEach-Object {get-itemproperty $_.PSPath} |
	    select-object DisplayName,InstallLocation,uninstallstring |
	    Where-Object {$_.DisplayName -ne $null -and $_.uninstallstring -ne $null -and $_.InstallLocation -ne $null})
}

# You can add additional uninstalls by copying and pasting the {$_.DisplayName -like "*Ask*" -or {$_.DisplayName -like "*Ask*" -or...
$uninstallapplist = $uninstallapplist | Where-Object {$_.InstallLocation -like "*jre*" } |
                                             sort-object DisplayName -Unique


# Now that we have the list - let's go through each one and uninstall it

foreach ($app in $uninstallapplist) {
	write-host "Uninstalling $($app.displayname) ...."
	if ($app.uninstallstring -like "msiexec.exe*") { 
    	$app.uninstallstring = $app.uninstallstring -replace "/I","/X"  
    	$app.uninstallstring = $app.uninstallstring -replace "msiexec.exe ","" 
    	$app.uninstallstring = "$($app.uninstallstring) /qn"
		
		$retcode = (start-process -filepath "msiexec.exe" -ArgumentList "$($app.uninstallstring)" -wait -passthru).exitcode
		
	}
	# If the uninstall command is not an msiexec program then we do things differently - Note: I have included the following code but not tested it yet - It should work :-)
	else {
		# If the uninstall command itself has double quotes around it because it has spaces in the path, then we have to use the "&" prefix
		if ($app.UninstallString[0] -eq '"') {Invoke-Expression "& $('$app.uninstallstring')"}
		# Otherwise we just invoke the uninstall string 
		else {Invoke-Expression "& $('$app.uninstallstring') /S"}
		# and get the exit code
		$retcode = $LASTEXITCODE
	}
	write-host "$($app.displayname) uninstalled - Return code: $retcode"
}
