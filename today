Add-Type -AssemblyName PresentationFramework

# Define XAML for WPF Layout
[xml]$xaml = @"
<Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Device Collection Management" Height="400" Width="600" WindowStartupLocation="CenterScreen">
    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>
        
        <TextBlock Grid.Row="0" FontSize="18" FontWeight="Bold" Text="Device Collection Management" HorizontalAlignment="Center" Margin="0,0,0,10"/>
        
        <StackPanel Grid.Row="1" Orientation="Horizontal" Margin="0,5">
            <TextBlock Text="Old Device Name:" VerticalAlignment="Center" Width="120"/>
            <TextBox x:Name="OldDeviceNameTextBox" Width="200" Margin="10,0"/>
            <Button x:Name="GetCollectionsButton" Content="Get Collections" Width="100" Margin="10,0"/>
        </StackPanel>
        
        <StackPanel Grid.Row="2" Orientation="Horizontal" Margin="0,5">
            <TextBlock Text="New Device Name:" VerticalAlignment="Center" Width="120"/>
            <TextBox x:Name="NewDeviceNameTextBox" Width="200" Margin="10,0"/>
            <Button x:Name="CheckDeviceButton" Content="Check Device" Width="100" Margin="10,0" IsEnabled="False"/>
        </StackPanel>
        
        <Button Grid.Row="3" x:Name="AddNewDeviceButton" Content="Add New Device to Collections" Background="Red" Foreground="White" Width="300" Height="30" HorizontalAlignment="Center" Margin="0,10"/>
        
        <ListBox Grid.Row="4" x:Name="OutputListBox" Margin="0,10,0,0" />
    </Grid>
</Window>
"@

# Load XAML
$reader = (New-Object System.Xml.XmlNodeReader $xaml)
$window = [System.Windows.Markup.XamlReader]::Load($reader)

# Define Controls
$oldDeviceNameTextBox = $window.FindName("OldDeviceNameTextBox")
$newDeviceNameTextBox = $window.FindName("NewDeviceNameTextBox")
$getCollectionsButton = $window.FindName("GetCollectionsButton")
$checkDeviceButton = $window.FindName("CheckDeviceButton")
$addNewDeviceButton = $window.FindName("AddNewDeviceButton")
$outputListBox = $window.FindName("OutputListBox")

# Placeholder for collections retrieved
$collectionsList = @()

# Helper function to update output
function Update-Output {
    param (
        [string]$message
    )
    # Update the OutputListBox on the main thread
    $window.Dispatcher.Invoke([action]{ $outputListBox.Items.Add($message) })
}

# Event Handler for Get Collections button
$getCollectionsButton.Add_Click({
    $oldDeviceName = $oldDeviceNameTextBox.Text
    if ([string]::IsNullOrWhiteSpace($oldDeviceName)) {
        [System.Windows.MessageBox]::Show("Please enter the old device name.", "Input Error", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Warning)
        return
    }

    # Run in a job to keep UI responsive
    Start-Job -ScriptBlock {
        param ($oldDeviceName)
        
        # Check if the device exists
        $device = Get-CMDevice -Name $oldDeviceName -ErrorAction SilentlyContinue
        if ($null -ne $device) {
            Update-Output "Device '$oldDeviceName' found in SCCM."
            
            # Retrieve collections containing "Discovery" and with this device as a member
            $collectionsList = Get-CMDeviceCollection | Where-Object {
                $_.Name -match 'Discovery' -and (Get-CMDeviceCollectionDirectMembershipRule -CollectionId $_.CollectionID | Where-Object {$_.ResourceID -eq $device.ResourceID})
            }
            
            if ($collectionsList.Count -gt 0) {
                Update-Output "Collections retrieved for device '$oldDeviceName':"
                $collectionsList | ForEach-Object { Update-Output " - $($_.Name)" }
                
                # Enable "Check Device" button on main thread
                $window.Dispatcher.Invoke([action]{ $checkDeviceButton.IsEnabled = $true })
            } else {
                Update-Output "No discovery collections found for device '$oldDeviceName'."
            }
        } else {
            Update-Output "Device '$oldDeviceName' not found in SCCM."
        }
    } -ArgumentList $oldDeviceName
})

# Event Handler for Check Device button
$checkDeviceButton.Add_Click({
    $newDeviceName = $newDeviceNameTextBox.Text
    if ([string]::IsNullOrWhiteSpace($newDeviceName)) {
        [System.Windows.MessageBox]::Show("Please enter the new device name.", "Input Error", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Warning)
        return
    }

    # Run in a job to keep UI responsive
    Start-Job -ScriptBlock {
        param ($newDeviceName)

        # Check if the new device exists
        $newDevice = Get-CMDevice -Name $newDeviceName -ErrorAction SilentlyContinue
        if ($null -ne $newDevice) {
            Update-Output "New device '$newDeviceName' found in SCCM."
        } else {
            Update-Output "New device '$newDeviceName' NOT found in SCCM."
        }
    } -ArgumentList $newDeviceName
})

# Event Handler for Add New Device to Collections button
$addNewDeviceButton.Add_Click({
    if ($collectionsList.Count -eq 0) {
        [System.Windows.MessageBox]::Show("No collections retrieved. Please fetch collections first.", "Action Error", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Warning)
        return
    }

    $newDeviceName = $newDeviceNameTextBox.Text
    if ([string]::IsNullOrWhiteSpace($newDeviceName)) {
        [System.Windows.MessageBox]::Show("Please enter the new device name.", "Input Error", [System.Windows.MessageBoxButton]::OK, [System.Windows.MessageBoxImage]::Warning)
        return
    }

    # Run in a job to keep UI responsive
    Start-Job -ScriptBlock {
        param ($newDeviceName, $collectionsList)

        # Retrieve the new device object
        $newDevice = Get-CMDevice -Name $newDeviceName -ErrorAction SilentlyContinue
        if ($null -eq $newDevice) {
            Update-Output "New device '$newDeviceName' not found in SCCM."
            return
        }

        # Add the new device to each retrieved collection
        foreach ($collection in $collectionsList) {
            Add-CMDeviceCollectionDirectMembershipRule -CollectionId $collection.CollectionID -ResourceId $newDevice.ResourceID
            Update-Output "Added '$newDeviceName' to collection '$($collection.Name)'"
        }
    } -ArgumentList $newDeviceName, $collectionsList
})

# Show the Window
$window.ShowDialog() | Out-Null


# button function#
# Event: Check Computer 1 (Old Device) and get collections
$CheckComputer1Button.Add_Click({
    $computer1 = $InputComputer1.Text
    $OutputBox.Clear()

    if ($computer1) {
        Update-OutputBox "Checking collections for $computer1..."

        Start-Job -ScriptBlock {
            $global:computer1Collections = Get-AllCollections -ComputerName $computer1

            if ($global:computer1Collections) {
                Update-OutputBox "Collections found for $computer1:"
                $global:computer1Collections | ForEach-Object {
                    Update-OutputBox " - $($_.Name)"
                }
                # Enable the "Check Computer 2" button if collections are found
                $CheckComputer2Button.Dispatcher.Invoke([action]{
                    $CheckComputer2Button.IsEnabled = $true
                })
            } else {
                Update-OutputBox "No collections found or computer does not exist."
                $CheckComputer2Button.Dispatcher.Invoke([action]{
                    $CheckComputer2Button.IsEnabled = $false
                })
            }
        } | Out-Null
    } else {
        Update-OutputBox "Please enter a valid computer name for the old device."
    }
})


#get collection#
# Function to retrieve all collections (static and dynamic) that a computer belongs to
function Get-AllCollections {
    param (
        [string]$ComputerName
    )

    try {
        # Retrieve the device by name
        $device = Get-CMDevice -Name $ComputerName
        if ($device) {
            $deviceID = $device.ResourceID
            $deviceCollections = @()

            # Loop through all collections
            Get-CMDeviceCollection | ForEach-Object {
                $collection = $_

                # Filter collections to include only those with "Discovery" in the name
                if ($collection.Name -like "*Discovery*") {
                    # Check if it's a direct membership collection
                    $directMembership = Get-CMDeviceCollectionDirectMembershipRule -CollectionId $collection.CollectionID -ErrorAction SilentlyContinue
                    if ($directMembership) {
                        # For direct membership collections, check if the device is directly a member
                        if ($directMembership.ResourceID -contains $deviceID) {
                            $deviceCollections += $collection
                        }
                    } else {
                        # For dynamic collections, we assume membership based on queries
                        # Unfortunately, there is no straightforward PowerShell cmdlet to directly evaluate dynamic membership.
                        # However, you could retrieve dynamic collections and assume that if the device is part of the evaluated query,
                        # then it belongs to this collection.
                        # So, we'll include the collection in our results.
                        $deviceCollections += $collection
                    }
                }
            }

            return $deviceCollections
        } else {
            return $null
        }
    } catch {
        Write-Warning "Failed to retrieve collections for $ComputerName - $_"
        return $null
    }
}







function Get-SCCMDeviceCollectionsByName {
    param (
        [string]$DeviceName,
        [string]$SiteCode
    )

    # Validate input
    if (-not $DeviceName) {
        Write-Error "Device name is required."
        return
    }
    if (-not $SiteCode) {
        Write-Error "Site code is required."
        return
    }

    # Load the Configuration Manager module if it's not already loaded
    if (-not (Get-Module -Name "$SiteCode:")) {
        Import-Module "$($SiteCode):" -ErrorAction Stop
    }

    try {
        # Connect to the SCCM site
        cd "$SiteCode:"

        # Get the device information
        $device = Get-CMDevice -Name $DeviceName -ErrorAction SilentlyContinue

        if (-not $device) {
            Write-Error "Device with name '$DeviceName' not found in SCCM."
            return
        }

        # Get all dynamic collections that contain "discovery" in their name
        $collections = Get-CMDeviceCollection | Where-Object {
            $_.Name -match 'discovery' -and $_.CollectionType -eq '2'  # CollectionType '2' is for dynamic collections
        }

        # Filter collections to see if the device is a member of them
        $deviceCollections = foreach ($collection in $collections) {
            $membership = Get-CMDeviceCollectionDirectMembershipRule -CollectionId $collection.CollectionID `
                          -ResourceId $device.ResourceID -ErrorAction SilentlyContinue
            if ($membership) {
                $collection
            }
        }

        # Output the list of collections the device belongs to
        if ($deviceCollections) {
            $deviceCollections | Select-Object Name, CollectionID
        }
        else {
            Write-Output "No dynamic collections with 'discovery' in the name found for the device '$DeviceName'."
        }

    } catch {
        Write-Error "An error occurred: $_"
    }
}
# Example usage
Get-SCCMDeviceCollectionsByName -DeviceName "MyDevice" -SiteCode "ABC"
